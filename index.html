<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebHAR ‚Äì Live HAR Dashboard (WASM + Watchdog)</title>

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <!-- ONNXRuntime-Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />

  <style>
    body { background:#f5f7fa; font-family:"Inter",sans-serif; padding:1.5rem; }
    .value-card,.prediction-card,.console-card {
      background:#fff;border-radius:.75rem;box-shadow:0 2px 8px rgba(0,0,0,0.1);padding:1rem;text-align:center;
    }
    .prediction-card{background:#eef7ff;color:#007bff;font-weight:700;font-size:1.5rem;}
    .plot-container{background:white;border-radius:.75rem;padding:1rem;box-shadow:0 2px 8px rgba(0,0,0,0.1);margin-top:1rem;}
    .small-text{font-size:.9rem;color:#555;}
    #consoleBox{
      background:#111;color:#0f0;font-family:monospace;font-size:.9rem;
      text-align:left;overflow-y:auto;max-height:260px;padding:.5rem;border-radius:.5rem;
      white-space:pre-wrap; word-wrap:break-word;
    }
    .badge-soft { background: #f1f5ff; color: #335; border-radius: .5rem; padding:.2rem .5rem; }
  </style>
</head>

<body>
  <div class="container">
    <h1>üì± WebHAR ‚Äì Real-Time HAR Dashboard</h1>

    <div class="d-flex flex-wrap align-items-center gap-3 mb-3">
      <label class="form-label mb-0">Model:</label>
      <select id="modelSelect" class="form-select w-auto">
        <!-- Filled at runtime; falls back to convnet.onnx -->
      </select>
      <span id="modelStatus" class="badge-soft">not loaded</span>

      <label class="form-label mb-0 ms-3">Rate (Hz):</label>
      <input id="rateSelect" type="number" min="1" max="100" value="20" class="form-control w-auto" />
      <label class="form-label mb-0">Gyro:</label>
      <select id="gyroUnit" class="form-select w-auto"><option value="rads" selected>rad/s</option><option value="degs">¬∞/s</option></select>
      <label class="form-label mb-0">Accel:</label>
      <select id="accType" class="form-select w-auto"><option value="linear" selected>Linear</option><option value="gravity">Incl. Gravity</option></select>
      <div class="form-check ms-2"><input class="form-check-input" type="checkbox" id="debugMode"><label class="form-check-label" for="debugMode">Debug</label></div>
      <button id="toggleButton" class="btn btn-success ms-2">Start</button>
      <button id="restartBtn" class="btn btn-outline-secondary">Restart Inference</button>
    </div>

    <div class="row text-center">
      <div class="col-md-6">
        <div class="value-card">
          <h5>Accelerometer (<span id="accUnit">m/s¬≤</span>)</h5>
          <div>X:<span id="ax">0</span> &nbsp; Y:<span id="ay">0</span> &nbsp; Z:<span id="az">0</span></div>
          <hr><div id="accStats" class="small-text"></div>
        </div>
      </div>
      <div class="col-md-6">
        <div class="value-card">
          <h5>Gyroscope (<span id="gyroUnitLabel">rad/s</span>)</h5>
          <div>X:<span id="gx">0</span> &nbsp; Y:<span id="gy">0</span> &nbsp; Z:<span id="gz">0</span></div>
          <hr><div id="gyroStats" class="small-text"></div>
        </div>
      </div>
    </div>

    <div class="prediction-card mt-4">
      Predicted Activity:
      <div style="font-size:2rem; line-height:1.2;">
        <span id="predEmoji">‚Äì</span>
        <span id="predActivity">‚Äì</span>
      </div>
      <span id="predTime">Last inference: ‚Äì</span><br>
      <span id="predLatency">Inference time: ‚Äì</span>
      <div class="small-text mt-1" id="loopStatus">Loop: idle</div>
    </div>

    <div class="plot-container mt-4">
      <h5>Accelerometer (m/s¬≤)</h5><div id="accPlot"></div>
    </div>
    <div class="plot-container">
      <h5>Gyroscope (rad/s)</h5><div id="gyroPlot"></div>
    </div>

    <div class="console-card mt-4">
      <h5>Console Output</h5>
      <div id="consoleBox">[ready]</div>
    </div>
  </div>

<script>
/* ====== CONFIG / STATE ====== */
const CLASSES=["sit","stand","walk","climb up","climb down","run"];
const CLASS_EMOJI = {
  "sit":"ü™ë", "stand":"üßç", "walk":"üö∂", "climb up":"ü™ú‚¨ÜÔ∏è", "climb down":"ü™ú‚¨áÔ∏è", "run":"üèÉ"
};
let session=null, creatingSession=false, currentModel="models/convnet.onnx";
let isRunning=false, loopRunning=false;
let buffer=[];
let SAMPLE_RATE=20;
const WINDOW_SEC=3, STEP_SEC=1;
let SAMPLES_PER_WINDOW=WINDOW_SEC*SAMPLE_RATE;
const STEP_INTERVAL=STEP_SEC*1000;
let startTime=null, debugTimer=null;
let lastSampleTs=0; // throttle devicemotion
const INFERENCE_TIMEOUT_MS = 4000;
let inferenceCount = 0;

/* ====== CONSOLE LOG ====== */
function log(msg, type="info"){
  const box=document.getElementById("consoleBox");
  const time=new Date().toLocaleTimeString();
  const safe=String(msg).replace(/</g,"&lt;").replace(/>/g,"&gt;");
  const color = type==="err" ? "#f55" : type==="ok" ? "#7f7" : "#0f0";
  box.innerHTML += `<span style="color:${color}">[${time}] ${safe}</span><br>`;
  const lines=box.innerHTML.split("<br>"); if(lines.length>600) box.innerHTML=lines.slice(-600).join("<br>");
  box.scrollTop=box.scrollHeight;
  (type==="err"?console.error:console.log)(msg);
}

/* ====== PLOTS ====== */
const accData={x:[],y:[],z:[],t:[]}, gyroData={x:[],y:[],z:[],t:[]};
Plotly.newPlot('accPlot',[
  {y:[],mode:'lines',name:'X',line:{color:'red'}},
  {y:[],mode:'lines',name:'Y',line:{color:'green'}},
  {y:[],mode:'lines',name:'Z',line:{color:'blue'}}
],{margin:{t:10},yaxis:{title:'m/s¬≤'},xaxis:{title:'Time (s)'}});
Plotly.newPlot('gyroPlot',[
  {y:[],mode:'lines',name:'X',line:{color:'orange'}},
  {y:[],mode:'lines',name:'Y',line:{color:'purple'}},
  {y:[],mode:'lines',name:'Z',line:{color:'teal'}}
],{margin:{t:10},yaxis:{title:'rad/s'},xaxis:{title:'Time (s)'}});

/* ====== MODEL DISCOVERY ====== */
const MODELS_DIR = "models/";

// Normalize a possibly-relative href to a clean path under MODELS_DIR
function joinModelsPath(href) {
  // ignore parent dirs and anchors
  if (!href || href.startsWith("#") || href.startsWith("?")) return null;
  // absolute links: keep if they already point inside models/
  try {
    const u = new URL(href, location.href);
    // Only allow files that live under MODELS_DIR
    const modelsUrl = new URL(MODELS_DIR, location.href);
    if (!u.href.startsWith(modelsUrl.href)) return null;
    // Return path relative to page origin (e.g., "models/foo.onnx")
    return u.pathname.replace(/^\//, "");
  } catch {
    return null;
  }
}

async function discoverModels() {
  // 1) Try directory listing (works on python http.server and many static servers)
  try {
    const listingUrl = new URL(MODELS_DIR, location.href).toString();
    const res = await fetch(listingUrl, { cache: "no-cache" });
    const html = await res.text();
    // parse all href="...onnx"
    const rawMatches = [...html.matchAll(/href="([^"]+\.onnx)"/gi)].map(m => m[1]);
    const normalized = rawMatches
      .map(h => joinModelsPath(new URL(h, listingUrl).href))
      .filter(Boolean);

    const unique = [...new Set(normalized)];
    if (unique.length) return unique;
  } catch (e) {
    console.warn("Directory listing parse failed:", e);
  }

  // 2) Try manifest file (see option 2 below)
  try {
    const res = await fetch(`${MODELS_DIR}manifest.json`, { cache: "no-cache" });
    if (res.ok) {
      const arr = await res.json(); // expects ["models/foo.onnx", ...] or ["foo.onnx", ...]
      const normalized = arr.map(p => p.startsWith(MODELS_DIR) ? p : `${MODELS_DIR}${p}`);
      if (normalized.length) return normalized;
    }
  } catch {}

  // 3) Final fallbacks
  // If you always have a default at models/convnet.onnx, list that
  return [`${MODELS_DIR}convnet.onnx`];
}

async function populateModelDropdown() {
  const sel = document.getElementById("modelSelect");
  const models = await discoverModels();

  sel.innerHTML = "";
  models.forEach(m => {
    const opt = document.createElement("option");
    opt.value = m;
    opt.textContent = m.replace(/^models\//, "");
    if (m === currentModel) opt.selected = true;
    sel.appendChild(opt);
  });

  // if the current model isn't in the list, use the first
  if (!models.includes(currentModel)) currentModel = models[0];

  document.getElementById("modelStatus").textContent = currentModel.replace(/^models\//, "");
}

document.getElementById("modelSelect").addEventListener("change", async (e)=>{
  currentModel = e.target.value;
  document.getElementById("modelStatus").textContent = currentModel.replace(/^models\//, "");
  log(`Model changed to: ${currentModel}`);
  await createSession(); // now loads fresh bytes (no cache)
});


/* ====== MODEL LOAD / RELOAD ====== */
async function createSession(){
  if (creatingSession) { log("createSession() already in progress"); return; }
  creatingSession = true;

  try{
    // show loading
    document.getElementById("predActivity").textContent = "‚Äì";
    document.getElementById("predEmoji").textContent = "‚Äì";
    document.getElementById("modelStatus").textContent = "loading...";
    const modelPath = currentModel; // snapshot in case user switches quickly
    log(`Loading ${modelPath} (WASM, single-thread) ...`);

    // Safe WASM config for sensors
    ort.env.wasm.numThreads = 1;
    ort.env.wasm.simd = true;
    ort.env.wasm.proxy = false;
    ort.env.logLevel = "warning"; // "verbose" if you want deeper logs

    // üí° Force a fresh fetch (no cache), then create session from bytes
    // Also set session=null to make the loop skip a cycle while we rebuild.
    session = null;
    const resp = await fetch(modelPath, { cache: "no-store" });
    if (!resp.ok) throw new Error(`HTTP ${resp.status} loading ${modelPath}`);
    const bytes = new Uint8Array(await resp.arrayBuffer());

    session = await ort.InferenceSession.create(bytes, { executionProviders: ["wasm"] });

    document.getElementById("modelStatus").textContent = modelPath.replace(/^models\//, "");
    log(`Model loaded: ${modelPath}`, "ok");
  } catch (e){
    log("Failed to create session: "+e, "err");
    session = null;
    document.getElementById("modelStatus").textContent = "load error";
  } finally {
    creatingSession = false;
  }
}


/* ====== SENSOR / DEBUG FEED ====== */
function pushSample(ax,ay,az,gx,gy,gz,now){
  buffer.push([ax,ay,az,gx,gy,gz]);
  if(buffer.length>SAMPLES_PER_WINDOW) buffer.shift();

  // live values
  document.getElementById("ax").textContent=ax.toFixed(2);
  document.getElementById("ay").textContent=ay.toFixed(2);
  document.getElementById("az").textContent=az.toFixed(2);
  document.getElementById("gx").textContent=gx.toFixed(2);
  document.getElementById("gy").textContent=gy.toFixed(2);
  document.getElementById("gz").textContent=gz.toFixed(2);

  // plot buffers (keep last 5s)
  accData.x.push(ax); accData.y.push(ay); accData.z.push(az); accData.t.push(now);
  gyroData.x.push(gx); gyroData.y.push(gy); gyroData.z.push(gz); gyroData.t.push(now);
  const maxT = now - 5;
  [accData,gyroData].forEach(d=>{ while(d.t.length && d.t[0] < maxT){ d.t.shift(); d.x.shift(); d.y.shift(); d.z.shift(); }});
  Plotly.update('accPlot',{x:[accData.t,accData.t,accData.t], y:[accData.x,accData.y,accData.z]}, {xaxis:{range:[Math.max(0, now-5), now]}});
  Plotly.update('gyroPlot',{x:[gyroData.t,gyroData.t,gyroData.t], y:[gyroData.x,gyroData.y,gyroData.z]}, {xaxis:{range:[Math.max(0, now-5), now]}});

  // stats
  updateStats(now);
}

function updateStats(now){
  const stats=a=>({min:Math.min(...a).toFixed(2), max:Math.max(...a).toFixed(2), mean:(a.reduce((x,y)=>x+y,0)/a.length).toFixed(2)});
  if(accData.x.length){ const s=stats(accData.x.concat(accData.y,accData.z));
    document.getElementById("accStats").innerHTML=`Mean:${s.mean}, Min:${s.min}, Max:${s.max}<br>Samples:${accData.t.length}, Time:${now.toFixed(2)} s`; }
  if(gyroData.x.length){ const s=stats(gyroData.x.concat(gyroData.y,gyroData.z));
    document.getElementById("gyroStats").innerHTML=`Mean:${s.mean}, Min:${s.min}, Max:${s.max}<br>Samples:${gyroData.t.length}, Time:${now.toFixed(2)} s`; }
}

// Throttled real sensor handler
let lastHz=20;
function handleMotion(e){
  if(!isRunning) return;
  const targetHz = parseFloat(document.getElementById("rateSelect").value)||20;
  if (targetHz !== lastHz) { lastHz = targetHz; SAMPLES_PER_WINDOW = WINDOW_SEC * targetHz; }
  const interval = 1000/targetHz;
  const nowTs = performance.now();
  if (nowTs - lastSampleTs < interval) return; // throttle
  lastSampleTs = nowTs;

  if(!startTime) startTime = performance.now();
  const now = (performance.now()-startTime)/1000;

  const accMode=document.getElementById("accType").value;
  const gyroMode=document.getElementById("gyroUnit").value;
  const acc= accMode==="gravity" ? e.accelerationIncludingGravity : e.acceleration;
  const ax=acc?.x??0, ay=acc?.y??0, az=acc?.z??0;
  let gx=e.rotationRate?.beta??0, gy=e.rotationRate?.gamma??0, gz=e.rotationRate?.alpha??0;
  if(gyroMode==="rads"){ gx*=Math.PI/180; gy*=Math.PI/180; gz*=Math.PI/180; }
  pushSample(ax,ay,az,gx,gy,gz,now);
}

// Debug generator
function startDebugMode(){
  SAMPLE_RATE=parseFloat(document.getElementById("rateSelect").value)||20;
  const dt=1000/SAMPLE_RATE; let t0=performance.now();
  debugTimer=setInterval(()=>{
    const now=(performance.now()-t0)/1000;
    const ax=Math.sin(now*2*Math.PI*1.5)+(Math.random()-0.5)*0.2;
    const ay=Math.cos(now*2*Math.PI*1.5)+(Math.random()-0.5)*0.2;
    const az=9.81+(Math.random()-0.5)*0.1;
    const gx=Math.sin(now*2*Math.PI*0.8)*0.05;
    const gy=Math.cos(now*2*Math.PI*0.8)*0.05;
    const gz=(Math.random()-0.5)*0.01;
    pushSample(ax,ay,az,gx,gy,gz,now);
  }, dt);
}
function stopDebugMode(){ if(debugTimer) clearInterval(debugTimer); debugTimer=null; }

/* ====== INFERENCE SAFE RUN + WATCHDOG ====== */
function timeoutPromise(ms){
  return new Promise((_, rej) => setTimeout(()=>rej(new Error(`watchdog timeout after ${ms}ms`)), ms));
}
async function safeRun(tensor){
  return Promise.race([ session.run({ input: tensor }), timeoutPromise(INFERENCE_TIMEOUT_MS) ]);
}

async function performInference(){
  if(!isRunning) return;
  if(!session){ log("‚ö†Ô∏è No session; skipping inference."); return; }
  const effectiveSamples = WINDOW_SEC * (parseFloat(document.getElementById("rateSelect").value)||20);
  if(buffer.length < effectiveSamples){ return; }

  const arr=buffer.slice(-effectiveSamples);
  const tensor=new ort.Tensor("float32", new Float32Array(arr.flat()), [1,6,60]); // model expects 60 @ 20Hz*3s
  const t0=performance.now();
  try{
    document.getElementById("loopStatus").textContent="Loop: running";
    inferenceCount += 1;
    log(`üß† [#${inferenceCount}] Running inference... (buffer=${buffer.length})`);
    const out = await safeRun(tensor);
    const latency = performance.now()-t0;
    const data = out[Object.keys(out)[0]].data;
    const pred = data.indexOf(Math.max(...data));
    const label = CLASSES[pred];
    const emoji = CLASS_EMOJI[label] || "ü§ñ";
    const ts = new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});

    document.getElementById("predEmoji").textContent = emoji;
    document.getElementById("predActivity").textContent = label;
    document.getElementById("predTime").textContent = "Last inference: " + ts;
    document.getElementById("predLatency").textContent = "Inference time: " + latency.toFixed(1) + " ms";
    log(`‚úÖ [#${inferenceCount}] Pred=${label} | latency=${latency.toFixed(1)} ms`, "ok");
  } catch(err){
    log(`‚ùå [#${inferenceCount}] Inference error: ${err}`, "err");
    await rebuildSessionIfNeeded(err);
  } finally {
    document.getElementById("loopStatus").textContent="Loop: idle";
  }
}

async function rebuildSessionIfNeeded(err){
  if(!isRunning) return;
  const msg = String(err||"");
  if (msg.includes("watchdog") || msg.includes("abort") || msg.includes("no available backend")) {
    log("üîÅ Recreating session due to watchdog/fatal error...");
    await createSession();
  }
}

/* ====== SEQUENTIAL LOOP (NO setInterval) ====== */
async function startInferenceLoop(){
  if(loopRunning){ log("Loop already running"); return; }
  loopRunning = true;
  log(`‚öôÔ∏è Starting sequential inference loop every ${STEP_INTERVAL/1000}s`);

  (async function loop(){
    while(isRunning){
      if(!session && !creatingSession){
        log("‚ö†Ô∏è Session missing; attempting to recreate...");
        await createSession();
      }
      await performInference();
      if(!isRunning) break;
      await new Promise(r=>setTimeout(r, STEP_INTERVAL));
    }
    loopRunning = false;
    log("üõë Inference loop exited.");
  })();
}

/* ====== UI BUTTONS ====== */
document.getElementById("toggleButton").onclick = async ()=>{
  if(!session) await createSession();

  if(isRunning){
    isRunning=false;
    window.removeEventListener("devicemotion",handleMotion);
    stopDebugMode();
    document.getElementById("toggleButton").textContent="Start";
    document.getElementById("toggleButton").classList.replace("btn-danger","btn-success");
    log("Stopped.");
  } else {
    isRunning=true;
    startTime=null; lastSampleTs=0; buffer.length=0; inferenceCount = 0;
    const debug=document.getElementById("debugMode").checked;
    if(debug){
      startDebugMode(); log("Debug mode active.");
    } else {
      if(DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission==="function"){
        try{ await DeviceMotionEvent.requestPermission(); } catch(e){ alert("Permission denied"); isRunning=false; return; }
      }
      window.addEventListener("devicemotion",handleMotion);
      log("Sensor capture started.");
    }
    startInferenceLoop();
    document.getElementById("toggleButton").textContent="Stop";
    document.getElementById("toggleButton").classList.replace("btn-success","btn-danger");
  }
};

document.getElementById("restartBtn").onclick = async ()=>{
  log("üîÑ Manual restart requested.");
  await createSession();
  if(isRunning && !loopRunning) startInferenceLoop();
};

/* ====== BOOT ====== */
(async function boot(){
  await populateModelDropdown();
  log(`Initial model: ${currentModel}`);
  await createSession(); // pre-load
})();
</script>
</body>
</html>

